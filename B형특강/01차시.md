## 비트연산

1. shift 연산
- << : 왼쪽 쉬프트 연산 사용하면 왼쪽으로 한칸 이동. 기존 수의 2배가 됨.
- long long 타입 : 64비트.
- 예시
    ```cpp
    long long a = 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111;

    a<<1; // [a*2]%(2**64) 비트연산하면, 값이 넘어감. 모듈연산값이 됨.
    ```

2. overflow
    ```cpp
    int a = 2147483647;

    a+=1; // overflow a=-2147483648 이 됨
    ```

3. overflow를 활용한 자료구조, Hash
- 추후 추가 설명

4. 예시
```cpp
int a = 1010....1;

a = a ^ (1<<8);
```

5. 비트 연산 활용
- 특정 위치를 0으로 바꾸고 싶을때, 0으로 **xor**
- 특정 위치를 0은 1로, 1은 0으로 변환하고 싶을때, 1로 **xor**
- 특정 위치를 1로 바꾸고 싶을때, 1로 **or**
- if((a & (1<<i)) == 1)
- a = 1111111111 (1이 k개로 구성된 이진수)
- a = (1<<k)-1

6. N==(N&M)
- N이 M에 포함되어 있는가의 여부를 나타냄

7. while(N-->0)
- N-1값이 0보다 크면 돌겠다는 듯
- while문 안에 들어가면 N-=1값임


## linked list

1. array와 linked list 차이
    ```
    array
    - 장점 : 무작위 접근 가능
    - 단점 : 삽입 및 삭제가 느림. 크기 조절 불가능

    linked list
    - 장점 : 삽입 및 삭제가 빠름. 크기 조절 가능
    - 단점 : 순차적 접근만 가능. 메모리 추가 할당
    - 시간복잡도 : 접근할때 O(N), 삭제할때 해당 위치 찾아야해서 O(N), 삽입 및 삭제 O(1)
    ```

2. linked list 단점
- runtime error 자주 남
- 라이브러리 지원되더라도 구현할 줄 알아야함
    - 기능이 어디까지 지원되는지 알아야해서
    - 지원되는 linked list로 구현할 수 없을 수도 있음

3. 단순 연결 리스트
- 내 뒤에 오는 얘만 기억함

4. 이중 연결 리스트
- 내 앞뒤롤 기억함

5. 원형 연결 리스트

6. 더미 노드
- 비어있는 linked list를 지워야하는 일이 발생함
- head : 링크드 리스트의 시작점
- 더미노드는 비어있는 노드이며, 시작 역할을 수행하는 노드임
- 필수는 아님

7. 메모리풀(정적할당방식)
    ```cpp
    // 동적할당

    Node* new_node(int data){
        Node* node = new Node;
        node->data = data;
        node->next = nullptr;
        return node;
    }
    ```
    ```cpp
    // 정적 할당
    int node_count = 0;
    Node node_pool[10000];

    Node* new_node(int data){
        node_pool[node_count].data = data;
        node_pool[node_count].next = nullptr;
        return &node_pool[node_count++];
    }
    ```
- 쉽게 말해, 미리 데이터 용량 최대로 잡아두고, 이용하는 거임
- 메모리풀 장점
    - 동적할당하면 오버헤드 발생함. 정적할당하면 시간초과 발생하지 않음.
    - 사용이 끝날때마다 메모리 해제할 필요가 없음
    - 모든 노드가 메모리상에서 뭉쳐있어서 캐시효율이 높음
        ```
        추가 설명하자면,

        동적할당하면, 메모리상에서 연결되어 형성되는 것이 아니라, 필요할때만 생성됨.

        그래서 링크드 리스트를 사용할때마다, cache miss가 발생하는데

        정적할당을 하면, 애초에 한 덩어리 전체가 캐시에 저장되서,
        cache miss 발생하지 않고, cache hit 원활하게 작동함
        ```
